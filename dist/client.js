var W=Object.defineProperty;var H=(e,s,t)=>s in e?W(e,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[s]=t;var u=(e,s,t)=>(H(e,typeof s!="symbol"?s+"":s,t),t),g=(e,s,t)=>{if(!s.has(e))throw TypeError("Cannot "+t)};var i=(e,s,t)=>(g(e,s,"read from private field"),t?t.call(e):s.get(e)),o=(e,s,t)=>{if(s.has(e))throw TypeError("Cannot add the same private member more than once");s instanceof WeakSet?s.add(e):s.set(e,t)},h=(e,s,t,n)=>(g(e,s,"write to private field"),n?n.call(e,t):s.set(e,t),t);import{debounce as D,noop as E}from"@nesvet/n";import G from"eventemitter3";function L(...e){for(let s of this.listenerHandlers)if(s.call(this,!0,...e)!==void 0)return;this.directOn(...e)}function _(...e){for(let s of this.listenerHandlers)if(s.call(this,!0,...e)!==void 0)return;this.directOnce(...e)}function T(...e){for(let s of this.listenerHandlers)if(s.call(this,!1,...e)!==void 0)return;this.directOff(...e)}function N(e){e.directOn=e.on,e.directOnce=e.once,e.directOff=e.off,e.listenerHandlers=new Set,e.on=L,e.once=_,e.off=T}var I=2e3,P=0,a,l,r,p,k,b,f,w,d,m,C=class extends G{constructor(t,n={}){super();u(this,"webSocket",null);o(this,a,D(function(){this.isOpen&&this.webSocket.close()},65e3));o(this,l,void 0);o(this,r,void 0);u(this,"isChanged",!1);o(this,p,()=>{i(this,l).call(this),h(this,l,void 0),h(this,r,void 0),this.emit("open"),i(this,a).call(this)});o(this,k,({data:t})=>{if(i(this,a).call(this),t)try{let[n,...c]=JSON.parse(t);this.emit("message",n,...c),this.emit(`message:${n}`,...c)}catch(n){i(this,b).call(this,n)}else this.webSocket.send("")});o(this,b,t=>{t instanceof Event&&(t=void 0),i(this,r)&&(i(this,r).call(this,t),h(this,l,void 0),h(this,r,void 0)),this.emit("error",t)});o(this,f,void 0);o(this,w,t=>{i(this,a).clear(),this.emit("close",t),this.autoReconnect&&![1002,3500,4e3].includes(t.code)&&h(this,f,setTimeout(()=>this.open().catch(E),I))});u(this,"connect",this.open);u(this,"disconnect",this.close);o(this,d,[]);o(this,m,()=>{for(let t of i(this,d))this.webSocket.send(t);i(this,d).length=0});N(this),this.url=t;let{name:c=P++,protocols:v,immediately:x=!0,autoReconnect:y=!0,on:S}=n;if(this.name=c,this.protocols=v,this.autoReconnect=y,S)for(let O in S)S[O]&&this.on(O,S[O]);this.url&&x&&this.open().catch(E)}get isConnecting(){return this.webSocket?this.webSocket.readyState===this.webSocket.CONNECTING:null}get isOpen(){return this.webSocket?this.webSocket.readyState===this.webSocket.OPEN:null}get isClosing(){return this.webSocket?this.webSocket.readyState===this.webSocket.CLOSING:null}get isClosed(){return this.webSocket?this.webSocket.readyState===this.webSocket.CLOSED:null}open(t={}){return clearTimeout(i(this,f)),this.close(4e3,"reopen").then(()=>(t.url&&(this.url=t.url),t.protocols&&(this.protocols=t.protocols),new Promise((n,c)=>{h(this,l,n),h(this,r,c),this.webSocket&&(this.isChanged=this.webSocket._url!==this.url,this.isChanged&&this.emit("server-change")),this.webSocket=new WebSocket(this.url,this.protocols),this.webSocket._url=this.url,this.emit("connecting"),this.send=this.webSocket.send.bind(this.webSocket),this.webSocket.addEventListener("open",i(this,p)),this.webSocket.addEventListener("message",i(this,k)),this.webSocket.addEventListener("error",i(this,b)),this.webSocket.addEventListener("close",i(this,w))})))}close(t=3500,n="manual"){return clearTimeout(i(this,f)),new Promise(c=>{this.isConnecting||this.isOpen?(this.webSocket.addEventListener("close",c),this.webSocket.close(t,n)):c()})}sendMessage(...t){let n=JSON.stringify(t);this.isOpen?this.webSocket.send(n):(i(this,d).length||this.once("open",i(this,m)),i(this,d).push(n))}};a=new WeakMap,l=new WeakMap,r=new WeakMap,p=new WeakMap,k=new WeakMap,b=new WeakMap,f=new WeakMap,w=new WeakMap,d=new WeakMap,m=new WeakMap;export{C as WebSocket};
//# sourceMappingURL=client.js.map
